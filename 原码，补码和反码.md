# 计算机存储的~原~码，~反~码，和补码

因为数学中有正负号的概念，因此计算机作为一个抽象也有表示符号的位置。在计算机中用一个数的最高位存放符号：+ 号表示为 0，- 号表示为 1 。例如： +3 在计算机中表示为 0000 0011，-3 在计算机中表示为 1000 0011。（以上及之后如无特殊说明，以8位为演算对象）

这样的表示形式就是机器数，真值就是将符号位转化为符号，例如：0000 0011 => +000 0011 => +3，1000 0011 => -000 0011 => -3,如果不转化的话，在形式上 1000 0011 === 131（128+3）,实际上真值是 -3。

## 原码

正数的~原~码，~反~码，和补码都是自己：[+1] = [00000001]~原~ = [00000001]~反~ = [00000001]~补~

**负数的反码和补码：**

1. 负数的反码是在原码的基础上，符号位不变，其余各个位取反；
2. 负数的补码是在反码的基础上 + 1。

[-1] = [10000001]~原~ = [11111110]~反~ = [11111111]~补~

#### 原因

为什么会出现反码和补码这种不能一眼看出值的表示形式？

计算机如果需要辨识“符号位”会让计算机的基础电路变的更加复杂，因此人们决定将符号位也参与运算，计算机减法可以表示为加上减数的负值，1 - 1 = 1 + (-1) = 0，这样可以只有加法，这样设计就更简单了。

- 原码

  1 - 1 = 1 + (-1) = [00000001] ~原~ + [10000001]~原~ = [10000010]~原~ = -2，原码计算会出现减法错误的情况。范围为[-127,127]

- 反码

  1 - 1 = 1 + (-1) = [0000 0001]~原~ + [1000 0001]~原~= [0000 0001]~反~ + [1111 1110]~反~ = [1111 1111]~反~ = [1000 0000]~原~ = -0，反码会导致出现+0和-0，会出现练个表示0的编码 [0000 0000]和[1000 0000]。范围为[-127,127]
  
- 补码

  1-1 = 1 + (-1) = [0000 0001]~原~ + [1000 0001]~原~ = [0000 0001]~补~ + [1111 1111]~补~ = [0000 0000]~补~=[0000 0000]~原~，补码解决了0的符号及两个编码的问题，于是用[1000 0000]表示-128,因此-128没有反码和原码。范围为[-128,127]

因此对于常见的32位int类型，可以表示的范围为[-2^31^,2^31^-1],使用补码可以多表示一个最小值

#### 应用的数学原理

两个整数a，b，若它们除以整数m所得的余数相等，则称a，b对于模m同余

记作 a ≡ b (mod m)

读作 a 与 b 关于模 m 同余。
$$
x \quad mod \quad y \quad = \quad x \quad - y \quad \lfloor x/y \rfloor, \quad\quad for \quad y \not= 0. 
$$
-3 mod 2 = -3 - 2 * -2 = 1.

 反身性:

> a ≡ a (mod m)

这个定理是很显而易见的.

线性运算定理:

> 如果a ≡ b (mod m)，c ≡ d (mod m) 那么:
>
> (1)a ± c ≡ b ± d (mod m)
>
> (2)a * c ≡ b * d (mod m)

计算机表示和余数的相同点在于，溢出的最高位，就像以以最大数进行了取模一样。

**反码:**

(-1) ≡ 126 (mod 127)

2-1 ≡ 2+126 (mod 127)

**补码**

(-1) mod 128 = 127

127 mod 128 = 127

2-1 ≡ 2+127 (mod 128)

此时, 相当于一个表盘每128个刻度转一轮. 所以用补码表示的运算结果最小值和最大值应该是[-128, 128]. 

但是由于0的特殊情况, 没有办法表示128, 所以补码的取值范围是[-128, 127]

